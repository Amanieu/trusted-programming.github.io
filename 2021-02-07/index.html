<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="github-pandoc.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#trusted-programming----our-rust-mission-at-huawei">Trusted Programming -- Our Rust Mission at Huawei</a><ul>
<li><a href="#innovations-by-rust">Innovations by Rust</a></li>
<li><a href="#contributions-to-rust-community-from-huawei">Contributions to Rust community from Huawei</a></li>
<li><a href="#adapting-end-to-end-rust-tooling-for-huawei">Adapting end-to-end Rust tooling for Huawei</a><ul>
<li><a href="#tokei"><code>tokei</code></a></li>
<li><a href="#cargo-geiger"><code>cargo-geiger</code></a></li>
</ul></li>
<li><a href="#research-on-rust-through-deep-code-learning">Research on Rust through Deep Code Learning</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></li>
</ul>
</div>
<p><a href="index-cn.html">中文</a></p>
<h1 id="trusted-programming----our-rust-mission-at-huawei">Trusted Programming -- Our Rust Mission at Huawei</h1>
<p><em>Yijun Yu</em></p>
<p>Chief Expert on Trusted Programming<br />
Trustworthy Open-Source Software Engineering Lab &amp;<br />
Ireland Research Centre<br />
Huawei Technology, Inc.</p>
<p><em>Amanieu d'Antras</em></p>
<p>Principal Rust Expert<br />
Trustworthy Open-Source Software Engineering Lab &amp;<br />
Ireland Research Centre<br />
Huawei Technology, Inc.</p>
<p><em>Nghi D. Q. Bui</em></p>
<p>Research Scientist<br />
Trustworthy Open-Source Software Engineering Lab &amp;<br />
Ireland Research Centre<br />
Huawei Technology, Inc.</p>
<h2 id="innovations-by-rust">Innovations by Rust</h2>
<p>Since 2015, Rust has consistently been voted as the most loved programming language in the StackOverflow survey.</p>
<p><img src="img/RustConChina2020-yu-v42.png" width="500" /><br />
There has also been an increasing number of publications on Rust at the recent top programming languages and software engineering conferences.</p>
<p><img src="img/RustConChina2020-yu-v43.png" /><br />
If that's not enough, a recent Nature 2020 article, `Why Scientists are Turning to Rust', says that there is increasing momentum on the adoption of Rust amongst scientists.</p>
<p><img src="img/RustConChina2020-yu-v41.png" width="500" /><br />
## Initial adoption of Rust at Huawei</p>
<p>At Huawei, we aim to engineer trustworthy software systems in the world's largest telecom industry.</p>
<p>For example, we are working to migrate parts of our codebase towards Rust, which is safer and as performant as C/C++. To assist our developers in this process, we are leveraging the open-source <a href="https://c2rust.com/">C2Rust</a> transpiler to generate Rust code directly from C. We have created automated tools to refactor and clean up this generated Rust code through source-to-source transformations.</p>
<p>We are also developing a rich set of internal libraries in Rust built around an actor-based concurrency paradigm. This simplifies asynchronous programming by leveraging Rust language features such as <code>async</code>, <code>await</code>, etc.</p>
<p>All these factors have led to increased adoption of Rust withing Huawei and smooth migration from C/C++ programs, which are dominant in the telecom industry. As the leading company in this industry and a founding member of the Rust Foundation, Huawei is committed to the the success of Rust and will continue contributing back to the Rust community.</p>
<h2 id="contributions-to-rust-community-from-huawei">Contributions to Rust community from Huawei</h2>
<p>We also contribute significant features back to the Rust community. For example, our recent contributions to the Rust compiler enable the compilation of Rust programs for big-endian and <a href="https://developer.arm.com/documentation/dai0490/latest/">ILP32</a> variants of AArch64. These changes enable Huawei and other hardware companies to run Rust code on networking hardware which commonly uses these architecture variants. This contribution is achieved with the help of our Rust expert Amanieu d'Antras, who has pushed through these pull requests to <a href="https://reviews.llvm.org/rG21bfd068b32ece1c6fbc912208e7cd1782a8c3fc">the LLVM compiler</a>, <a href="https://github.com/rust-lang/libc/pull/2039">the libc crate</a>, and <a href="https://github.com/rust-lang/rust/pull/81455">the Rust compiler itself</a>. These changes introduce new end-to-end cross-compilation targets for the Rust compiler, making it easier to build Rust products for bespoke hardware using a single command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">cargo</span> build --target aarch64_be-unknown-linux-gnu
<span class="ex">cargo</span> build --target aarch64-unknown-linux-gnu_ilp32
<span class="ex">cargo</span> build --target aarch64_be-unknown-linux-gnu_ilp32</code></pre></div>
<p>With respect to community engagement, Huawei has been leading the effort in China, strategically sponsored <a href="https://2020conf.rustcc.cn">the first Rust China Conf</a> during December 26-27 in Shenzhen. We have started to lead the community by carrying out several activities, including creating Rust tutorials and Rust coding conventions in Chinese for a vast number of developers who are interested in Rust.</p>
<h2 id="adapting-end-to-end-rust-tooling-for-huawei">Adapting end-to-end Rust tooling for Huawei</h2>
<p>There are many end-to-end tools out there in the Rust community and we have started to benefit from the interactions with developers of these tools.</p>
<p>Here are just a few examples.</p>
<h3 id="tokei"><code>tokei</code></h3>
<p>Because trustworthy programming typically involves migrating programming languages, we have adopted <a href="https://github.com/XAMPPRocky/tokei"><code>tokei</code></a> as our code complexity metrics tool, which can recognize as many as 200 languages. For For example, the following statistics show how many lines of code various programming languages have been developed in Google's Fucshia project:</p>
<p><img src="img/RustConChina2020-yu-v49.png" /><br />
It is relatively easy to plot the proportion of C, C++, Rust code in the evolution of Fucshia, as follows:</p>
<p><img src="img/RustConChina2020-yu-v410.png" /><br />
To accommodate the needs to processing multiple programming languages in our projects, we have made a <a href="https://github.com/XAMPPRocky/tokei/pull/678">pull request to <code>tokei</code></a> to support batch processing of recognized languages.</p>
<h3 id="cargo-geiger"><code>cargo-geiger</code></h3>
<p>To improve safety, we would like to know how much code has been checked by the Rust compiler. Fortunately, <a href="https://github.com/rust-secure-code/cargo-geiger"><code>cargo-geiger</code></a> does almost this by counting the statistics of <code>unsafe</code> items such as <code>fn</code>, <code>expr</code>, <code>struct</code>, <code>impl</code>, <code>trait</code>, and their occurrences in various dependent crates:</p>
<p><img src="img/RustConChina2020-yu-v411.png" /><br />
However, the statistics do not reflect the ratio of safe items, hence not showing how much has been achieved overall for Rust projects. Therefore, we made a <a href="https://github.com/rust-secure-code/cargo-geiger/pull/167">pull request</a> to <code>cargo-geiger</code> to report the checked safe ratios of Rust projects. After it was accepted, this tool has been used regularly by our product teams on daily basis. A report will look like the following, which has made it easier to tell which crates have not been fully checked by the Rust compiler:</p>
<p><img src="img/RustConChina2020-yu-v412.png" /><br />
<img src="img/RustConChina2020-yu-v413.png" /></p>
<h2 id="research-on-rust-through-deep-code-learning">Research on Rust through Deep Code Learning</h2>
<p>As codebases from the Rust open-source community evolve and grow, new developers need to learn the best practices, including but not limited to the language itself. Statistical machine learning methods from a large amount of source code, also known as <a href="https://arxiv.org/abs/1709.06182">Big Code</a>, have been considered by software engineering research communities: similar to the machine-learning problems for image processing and natural language processing where a vast number of features requires deep neural networks (DNN) to extract, big code may also be used to train a DNN to reflect on statistical patterns of programs, which is called `Deep Code Learning'.</p>
<p>In this respect, Huawei is pushing the limits by improving the state-of-the-art of `cross-language' deep code learning, through a technical collaboration with <a href="https://mcs.open.ac.uk/yy66">The Open University, UK</a> and <a href="http://www.mysmu.edu/faculty/lxjiang/">Singapore Management University</a>.</p>
<p>For example, initial deep code learning methods are trained and evaluated using the benchmarks of 52,000 C/C++ programs of 104 algorithm classes collected from the programming courses of Peking University. Traditionally, tree-based convolution neural networks (TBCNN) could achieve 94% accuracy in algorithm classification for this dataset <a href="https://github.com/bdqnghi/tbcnn.tensorflow">(AAAI'16)</a>. A recent progress of the SOTA using abstract syntax trees at the statement level <a href="https://github.com/zhangj111/astnn">(ICSE'19)</a> achieved 98% accuracy. Our recent progress pushes the SOTA even higher to achieve 98.4% accuracy <a href="https://arxiv.org/abs/2009.09777">(AAAI'21)</a> by an innovation on Tree-based Capsule Networks.</p>
<p>Earlier, we have used cross-language datasets to show that the learned model of one language applies to another programming language. For example, using the Rosetta Code datasets from Github, we show it possible to obtain 86% accuracy for algorithm classification (Java to C) <a href="https://github.com/bdqnghi/bi-tbcnn">(SANER'19)</a>, and cross-language API mapping problems (Java to C#) <a href="https://github.com/bdqnghi/SAR_API_mapping">(ESEC/FSE'19)</a>. These statistical language models have found multiple applications to software engineering, in terms of code classification, code search, code recommendation, code summary, method name prediction, and code clone detection <a href="https://github.com/bdqnghi/infercode">(ICSE'21)</a>. Such models also have the capability to transfer the knowledge across many tasks, thus it will reduce the effort to retrain the models for each of the tasks separately.</p>
<p>To analyze Rust projects, we have made another pull request to the Rust parser project <a href="https://github.com/tree-sitter/tree-sitter/pull/863"><code>tree-sitter</code></a> and XML serialization crate <a href="https://github.com/tafia/quick-xml/pull/250"><code>quick-xml</code></a>, which allow us to feed the abstract syntax trees of Rust programs to train a deep code learning model. The preliminary results are quite promising, the detection algorithms in Rust can reach an accuracy as high as 85.5%. This number is still climbing as we continue working on improving toolchains.</p>
<p>A prototype of such an IDE is shown as an extension to the Visual Studio Code，where programmers are assisted with the recommendation of a suitable algorithm and an explanation of the choice. <img src="img/RustConChina2020-yu-v414.png" /></p>
<h2 id="conclusion">Conclusion</h2>
<p>In summary, the Huawei Trustworthy Open-Source Software Engineering Lab is working hard to provide programmers an end-to-end IDE toolchain that intelligently assists in maximizing safety and performance.</p>
<p>A journey towards the vision of Trusted Programming has just begun and we hope to work collaboratively with the Rust community, and the upcoming Rust Foundation, to lead a smooth revolution to the Telecom software industry.</p>
</body>
</html>
