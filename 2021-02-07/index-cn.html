<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>blog_cn</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="github-pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#可信编程-华为引领rust语言开发的实践和愿景">可信编程 – 华为引领Rust语言开发的实践和愿景</a>
<ul>
<li><a href="#rust带来的创新">Rust带来的创新</a></li>
<li><a href="#rust在华为的初步推进">Rust在华为的初步推进</a></li>
<li><a href="#华为对rust社区的贡献">华为对Rust社区的贡献</a></li>
<li><a href="#配置华为的端到端rust工具链">配置华为的端到端Rust工具链</a>
<ul>
<li><a href="#tokei">tokei</a></li>
<li><a href="#cargo-geiger">cargo-geiger</a></li>
</ul></li>
<li><a href="#通过深度代码学习研究rust">通过深度代码学习研究Rust</a></li>
<li><a href="#结论">结论</a></li>
</ul></li>
</ul>
</nav>
<p><a href="index.html">English</a></p>
<h1 id="可信编程-华为引领rust语言开发的实践和愿景">可信编程 – 华为引领Rust语言开发的实践和愿景</h1>
<p><em>Yijun Yu</em></p>
<p>可信编程首席专家<br />
华为可信软件工程开源实验室<br />
华为爱尔兰研究所</p>
<p><em>Amanieu d’Antras</em></p>
<p>Rust高级专家<br />
华为可信软件工程开源实验室<br />
华为爱尔兰研究所</p>
<h2 id="rust带来的创新">Rust带来的创新</h2>
<p>StackOverflow的调查表明, 自2015年以来，Rust一直是开发者最爱的编程语言。</p>
<p><img src="img/RustConChina2020-yu-v42.png" width="500" /><br />
</p>
<p>学术界对于Rust也越来越重视，在编程语言和软件工程顶会上发表的关于Rust的论文正逐年增加。</p>
<p><img src="img/RustConChina2020-yu-v43.png" /><br />
</p>
<p>不仅如此，《自然》杂志2020年尾的文章《Why Scientists are Turning to Rust》中也强调：科学家极为推崇Rust。</p>
<p><img src="img/RustConChina2020-yu-v41.png" width="500" /><br />
</p>
<h2 id="rust在华为的初步推进">Rust在华为的初步推进</h2>
<p>华为的目标是引领通信系统软件向安全可信演进，其中Rust语言正在发挥很大的作用。</p>
<p>例如，我们希望通过部分C/C++代码的迁移，在保证高性能的同时，拥有更高的安全性。在此过程中， 我们为开发者提供一套自动化工具支持：基于开源的<a href="https://c2rust.com/">C2Rust</a>转译工具， 首先从C代码生成Rust代码, 然后通过源到源变换工具自动重构。</p>
<p>在华为内部我们还基于actor的并发编程模式开发了Rust库，方便程序员充分利用 Rust的语言特性, 例如<code>async</code>, <code>await</code>等。</p>
<p>以华为代表的通信系统软件的开发以C/C++代码为主, 这些Rust库将使C/C++到Rust的迁移更加顺畅。 作为业界领先公司和Rust基金会的创始成员，华为致力于Rust在通信软件行业，并将持续为Rust社区做出贡献。</p>
<h2 id="华为对rust社区的贡献">华为对Rust社区的贡献</h2>
<p>我们为Rust社区贡献了许多重要的功能特性。例如，我们最近为Rust编译器提交了一系列代码，使得Rust编译目标可以支持ARM AArch64 32位大端变体<a href="https://developer.arm.com/documentation/dai0490/latest/">ILP32</a>芯片组, 用于我们的通信产品中。 这些改进使得我们和友商可以在这些常用网络硬件架构上执行Rust原生程序。这些代码已经通过我们的Rust专家Amanieu d’Antras 提交给了<a href="https://reviews.llvm.org/rG21bfd068b32ece1c6fbc912208e7cd1782a8c3fc">LLVM 编译器</a>, <a href="https://github.com/rust-lang/libc/pull/2039">libc库</a>, 以及<a href="https://github.com/rust-lang/rust/pull/81455">Rust编译器</a>等开源社区。</p>
<p>这些对Rust编译器的更改引入了新的端到端交叉编译目标，针对定制硬件构建Rust产品变得更容易,只需要简单的命令，比如：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> build --target aarch64_be-unknown-linux-gnu</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> build --target aarch64-unknown-linux-gnu_ilp32</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> build --target aarch64_be-unknown-linux-gnu_ilp32</span></code></pre></div>
<p>华为在中国Rust社区方面也走在前列，战略支持12月26日至27日在深圳举办了<a href="https://2020conf.rustcc.cn">第一届中国Rust大会</a>，并推行多项 社区活动，包括为中国的开发者提供Rust教程和Rust编码规范。</p>
<h2 id="配置华为的端到端rust工具链">配置华为的端到端Rust工具链</h2>
<p>Rust社区中有几种端到端的工具，我们已经开始从开发人员和工具的交互中获取信息。</p>
<p>这里有一些例子</p>
<h3 id="tokei">tokei</h3>
<p>由于可信编程项目通常涉及多个编程语言，我们采用了<a href="https://github.com/XAMPPRocky/tokei"><code>tokei</code></a>作为多语言代码复杂性度量工具，识别多达200种编程语言。例如，开源的Fuchhia项目涉及了多种编程语言，下面的统计信息显示有多少行不同语种的代码：</p>
<p><img src="img/RustConChina2020-yu-v49.png" /><br />
</p>
<p>C、C++、Rust代码在Fuchhia项目的占比，可以绘制成如下演进图：</p>
<p><img src="img/RustConChina2020-yu-v410.png" /><br />
</p>
<p>为了在大型项目中满足处理多种编程语言的场景需求，我们提交代码到<a href="https://github.com/XAMPPRocky/tokei/pull/678">tokei</a>支持识别编程语言的批处理。</p>
<h3 id="cargo-geiger">cargo-geiger</h3>
<p>为了提高安全性，我们经常想知道有多少代码已经被Rust编译器检查过。幸运的是，通过统计“不安全”项目，如<code>fn</code>、<code>expr</code>，<code>struct</code>、<code>impl</code>、<code>trait</code>及其在各相关库实现中的出现次数， <a href="https://github.com/rust-secure-code/cargo-geiger">cargo-geiger</a>几乎做到了这点。</p>
<p><img src="img/RustConChina2020-yu-v411.png" /><br />
</p>
<p>不过，统计数字中并没有反映安全性，所以没办法展现Rust项目总体上取得了多少进展的比例。因此，我们 提交了<a href="https://github.com/rust-secure-code/cargo-geiger/pull/167">代码</a>，在改进的<code>cargo-geiger</code>计数器报告中提供Rust项目的安全检查比率。这个代码采纳后，我们的产品团队现在每天定期都在使用这个工具，一份典型的报告能够更容易理解哪些代码库还没被Rust编译器完全检查到。</p>
<p><img src="img/RustConChina2020-yu-v412.png" /><br />
<img src="img/RustConChina2020-yu-v413.png" /><br />
</p>
<h2 id="通过深度代码学习研究rust">通过深度代码学习研究Rust</h2>
<p>随着Rust开源社区代码的发展和革新，初学者需要学习掌握Rust最佳的实践，其包括但不限于Rust语言本身。把统计机器学习的方法应用到源代码数据上，也称为<a href="https://arxiv.org/abs/1709.06182">大代码</a>，正被全世界的软件工程研究团队关注：类似于 图像处理和自然语言处理中的机器学习问题，这些问题都需要通过深度神经网络(deep neural networks DNN)提取大量的特征，Big Code可能同样需要去训练DNN来反映程序的统计特性，所以也称为“深度代码学习”。</p>
<p>在这方面，华为与<a href="https://mcs.open.ac.uk/yy66">英国开放大学</a>和<a href="http://www.mysmu.edu/faculty/lxjiang/">新加坡管理大学</a>进行技术合作，在现在最先进的“跨语言”深度代码学习基础上进行优化研究。</p>
<p>例如，最初的深度代码学习方法应用于北京大学编程课程收集到的104个算法类的5.2万个C/C++程序。对此数据集，树基卷积神经网络(TBCNN)算法分类准确率达到94%<a href="https://github.com/bdqnghi/tbcnn.tensorflow">(AAAI’16)</a>。最近的SOTA在语句级使用抽象语法树 <a href="https://github.com/zhangj111/astnn">(ICSE ’19)</a>准确率达到98%。近期我们同<a href="https://mcs.open.ac.uk/yy66">英国开放大学</a>和<a href="http://www.mysmu.edu/faculty/lxjiang/">新加坡管理大学</a>在树基胶囊网络的合作研究进展推动了SOTA进一步提高，达到98.4%的准确率<a href="https://arxiv.org/abs/2009.09777">(AAAI’21)</a>。</p>
<p>早些时候我们已经使用跨语言的数据集表明，对一种编程语言的深度代码学习模型也适用于另一种编程语言。例如，从GitHub爬取的数据集Rosetta Code，从Java到C语言，可以获得86%的算法分类准确度 <a href="https://github.com/bdqnghi/bi-tbcnn">(SANER’19)</a>，在Java到C#的跨语言API映射 问题也能发挥重要作用<a href="https://github.com/bdqnghi/SAR_API_mapping">(ESEC/FSE’19)</a>。这些统计语言模型在软件工程中可以应用于很多方面，比如代码分类、代码搜索、代码推荐、代码摘要、方法名称预测、代码克隆检测等等<a href="https://github.com/bdqnghi/infercode">(ICSE’21)</a>。</p>
<p>为了进一步研究分析Rust项目，我们向<a href="https://github.com/tree-sitter/tree-sitter/pull/863">Rust解析器项目tree-sitter</a>和XML序列化 <a href="https://github.com/tafia/quick-xml/pull/250">quick-xml</a>等项目提交了代码，通过 Rust程序的抽象语法树来训练深度代码学习模型。研究的初步结果很有希望，算法检测任务在 Rust代码上的精度高达85.5%。随着工具链的改进，这个比例还有望进一步提升。</p>
<p>在IDE上的原型是在Visual Studio Code IDE上，我们开发扩展插件，使得程序员可以得到合适的算法推荐和可解释性的帮助。</p>
<h2 id="结论">结论</h2>
<p>综上所述，华为可信开源软件工程实验室正在开展的Rust工作为程序员提供智能化端到端IDE工具链，以期最大限度地提高代码的安全性和性能。走向可信编程远景的旅程刚刚开始，我们希望与Rust社区和即将成立的Rust基金会深度合作，引领电信软件产业的可信革新。</p>
</body>
</html>
